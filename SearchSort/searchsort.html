<!DOCTYPE html>
<html>
<head>
  <title>Feng's Portfolio</title>
  <base href = "https://fengxiong322.github.io/"><script type="text/javascript" src="interactions.js"></script>
  <link rel="icon" href="favicon.ico">
  <link rel="stylesheet" href="htmllayout.css">
</head>

<body><nav>
  <button class= "menubutton" onclick = "sideBar()"></button>
  <a href= "index.html">Home</a>
  <p></p>
  <a href = "OOP/OOPmenu.html">OOP</a>
  <p></p>
  <a href="Recursion/recursion.html">Recursion</a>
  <p></p>
  <a href="Arrays/arraysandarraylists.html">Arrays and Arraylists</a>
  <p></p>
  <a class = "current" href="SearchSort/searchsort.html">Search and Sort</a>
  <p></p>
  <a href="Projects/projects.html">Projects</a>
  <p></p>
  <a href="about.html">About</a>
</nav>

<header>
  <h2>Searching and Sorting</h2>
</header>

<section>
  <aside>
    <u><b><p>TABLE OF CONTENTS</p></b></u>
    <table style="width:100%">
      <tr>
        <td class = "current"><a href="SearchSort/searchsort.html">Searching And Sorting</a></td>
      </tr>
    </table>
  </aside>

  <article>
    <h2>Searching and Sorting</h2>
    <a href = "SearchSort/searchsort.html#search">Searching</a><br>
    <a href = "SearchSort/searchsort.html#linear">Linear Search</a><br>
    <a href = "SearchSort/searchsort.html#binary">Binary Search</a><br>
    <a href = "SearchSort/searchsort.html#sorting">Sorting</a><br>
    <a href = "SearchSort/searchsort.html#selection">Selection Sort</a><br>
    <a href = "SearchSort/searchsort.html#bucket">Bucket Sort</a><br>
    <br>
    <h1 id = "search">Searchs</h1>
    <p>First, we will begin with searchs. These are algorithms used to search for a particular item in an array. For the purpose of this tutorial, we will be sticking to integer values. However, code here can easily be modified to deal with other values, such as Strings.</p>
    <h2 id = "linear">Linear Search</h2>
    <p>As the name implies, this search method searches each position in a linear fashion, progressing from the first index, up until the search finds the object or the array ends. Below is a quick implementation of a linear search, for integers, which can easily be adapted to search for other types of objects</p>
    <pre class = codeSample>
      public int linearSearch(int[] arr, int item){//Returns the index, and will return -1 if it does not appear in the array
        for(int i = 0; i < arr.length; i++){
          if(arr[i] == item)
            return i;
        }
        return -1;
      }
</pre>
    <h2 id = "binary">Binary Search</h2>
    <p>Binary search is a specialized search for sorted arrays. This search is based on the assumption that the array is already sorted. Try to read through the implementation, before you read about the logic behind it</p>
    <pre class = codeSample>
  public static int binarySearch (int[] arr, int item)
  {
    int min = 0;
    int max = arr.length - 1;
    while (min!=max-1)
    {
      int middle = (max+min)/2;
      if(arr[middle] == item)
        return middle;
      if(arr[middle]>item)
        max = middle;
      else
        min = middle;
    }
    return -1;
  }
</pre>
    <p>The search begins at the middle of the array. It then checks the value of the middle index, and compares it with the item we are looking for. If they are the same, we can return the index. If the item is bigger, then we know that it must be in the upper half of the array, and if the item is smaller, we know it is in the lower half of the array. This halfs the distance we need to compare. This process repeats, until either the middle is matched with the item, or the max and min become too close, at which we decide that the item cannot possibly be in the array, and we return -1.</p>
    <h1 id  = "sorting">Sorts</h1>
    <p>Now that you understand various different types of searchs, we can now learn some sorts. Many sorts make uses of searching algorithms to find and sort an element. There are two main types of sorts: Comparision sorts and non-comparision sorts. Comparision sorts sort by comparing the values of two elements to decide where they need to be placed. Non-comparision sorts however do not need to make direct comparisions between each value. Instead, they are categorized.</p>
    <h2 id = "selection">Selection Sort</h2>
    <p>The selection sort is one of the easiest sorting algorithms to implement, but also one of the slowest. It is not very practical, but it is important to understand how it works. A selection sort works by finding the next element to sort</p>
<pre>
Starting Array:
1, 5, 2, 4, 3
We want to sort in ascending order
We want start by finding the lowest number in the entire array.
First, we assume the minimum, is the first element. In this case it is 1.
We then compare the minimum with the other numbers
is 5 less then 1? No
is 2 less then 1? No
is 4 less then 1? No
is 3 less then 1? No
So our first number would be 1.
<b>1</b>, 5, 2, 4, 3
We repeat the same process with the unsorted section.
We start by assuming 5 is the smallest number.
is 2 less then 5? Yes, now, the new smallest number is 2.
is 4 less then 2? No
is 3 less then 2? No
Our next number is 2. We put it in the second slot, and shift everything else down
<b>1, 2</b>, 5, 4, 3
We repeat this process again.
We assume that 5 is the smallest number.
Is 4 less then 5? Yes, the new smallest number is 4
Is 3 less then 4? Yes, the smallest number is 3
Here, we put 3 in the third slot, and shift everything else down
<b>1, 2, 3</b>, 5, 4
We repeat this process one more time
We assume 5 is the smallest number.
Is 4 less then 5? Yes, the smallest number is 4
We move 4 to the second last s
</pre>
    <h2 id = "bucket">Bucket Sort</h2>
    <p>The bucket sort is a non-comparison sort. This means that no two items are compared to each other. Instead, each item is categorized into a "bucket". Each bucket holds a certain range/type of value, specified by the programmer.</p>

    <p>Each item is categorized into a bucket. This is really helpful because it breaks our original problem into subgroups. After each element is sorted into a separate bucket, we can manipulate it it many different ways. The first way we can sort each individual bucket is a selection/insertion sort. More on selection sort here: <a href = "SearchSort/searchsort.html#selection"></a>. You can also find information on insertion sort <a></a>. You may be wondering about the time complexity of this bucket sort. Because this algorithm uses a selection/insertion sort, wouldn't the time complexity be slower than O(n<sup>2</sup>)? Although the worst case scenario for a bucket sort is indeed O(n<sup>2</sup>), it's average time is optimized. If you use the bucket sort in the correct way, an O(n<sup>2</sup>) solution will be very rare. To see why lets take a look at what the bucket sort does.</p>
    <img src="https://docs.google.com/drawings/d/e/2PACX-1vQq1IU1iZvJvI_tRk9jejQpxIVASBTkQXkwhCPJb1GMkPih-40M9n0Sc3DnGX9ETO48GRCb18RNfv8q/pub?w=960&amp;h=720">
    <p>In the diagram above, we realize that the selection sort can be optimized. This is because the algorithm does not have to travel through the entire array. Most of the work has already been done by the bucketsort.</p>
    <p>However, unlike comparison sorts, require some understanding of the range of your data. If you have no idea what kind of numbers may appear, a bucket sort may not be suitable. Before choosing to use bucket sort, you need to do a few checks. First of all, you need to confirm a range of the data set. For instance, a percentage. Percents are normalized and are typically between 0% and 100%. Another thing to look out for is distribution. If we had a dataset of percentages, but all of them are within 95%-100%, it wouldn't make sense to create buckets for 0%-9%, 10%-19%, 20%-29% and so on.</p>
    <p>A random number generator will be generating random integers from 1 to 100. Your job is to implement a bucket sort. Each bucket should have a range of 10. Some code has already been set up for you.</p>
    <pre class = "interactive" contenteditable="true">
import java.util.*;

public class BucketSort{
  int data[];

  public BucketSort(int size){
    data = new int[size];
    for(int i = 0; i < size; i++){
      data[i] = Math.random()*100;
    }
  }

  public void sort(){
    //YOUR IMPLEMENTATION HERE
  }

  public String toString(){
    for(int i = 0; i < data.length; i++)
      System.out.print(data[i] + " ");
  }

  public static void main(String[]args){
    BucketSort bs = new BucketSort(20);

  }
}</pre>
<button onclick = "displayAnswer('bucketsort')">Compare</button>
<iframe class = "answers" id = bucketsort  src = "SearchSort/BucketSort.java"></iframe>
  </article>
</section>

<footer>
  <p>Created by Feng</p>
</footer>

</body>

</html>
